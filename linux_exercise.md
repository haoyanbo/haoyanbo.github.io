三、liunx操作系统
1.熟练netstat tcpdump ipcs ipcrm
netstat:检查网络状态，tcpdump:截获数据包，ipcs:检查共享内存，ipcrm:解除共享内存
2.共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？
将一块内存映射到两个或者多个进程地址空间。通过指针访问该共享内存区。一般通过mmap将文件映射到进程地址共享区。
存在于进程数据段，最大限制是0x2000000Byte
3.进程内存空间分布情况
4.ELF是什么？其大小与程序中全局变量的是否初始化有什么关系（注意未初始化的数据放在bss段）
5.动态链接和静态链接的区别？
6.32位系统一个进程最多有多少堆内存
7.写一个c程序辨别系统是64位 or 32位
8.写一个c程序辨别系统是大端or小端字节序
9.信号：列出常见的信号，信号怎么处理？
10.i++ 是否原子操作?并解释为什么?
11.说出你所知道的各类linux系统的各类同步机制（重点），什么是死锁？如何避免死锁（每个技术面试官必问）
12、exit() _exit()的区别？
13、如何实现守护进程？
14、linux的任务调度机制是什么？
15、标准库函数和系统调用的区别？
16、系统如何将一个信号通知到进程？
17. fork()一子进程程后父进程的全局变量能不能使用？
18. 请画出socket通信连接过程
19. 请用socket消息队列实现“同步非阻塞”和“异步阻塞”两种模式，并指出两者的差别和优劣
四、网络编程

TCP头大小，包含字段？三次握手，四次断开描述过程，都有些什么状态。状态变迁图。TCP/IP收发缓冲区（2次）
头部大小是20字节，包含数据如下：
三次握手：
四次释放：
状态变迁图：
收发缓冲区：
使用udp和tcp进程网络传输，为什么tcp能保证包是发送顺序，而 udp无法保证？
epoll哪些触发模式，有啥区别？（必须非常详尽的解释水平触发和边缘触发的区别，以及边缘触发在编程中要做哪些更多的确认）
tcp与udp的区别（必问）为什么TCP要叫做数据流？
5．流量控制和拥塞控制的实现机制
滑动窗口的实现机制
epoll和select的区别？
网络中，如果客户端突然掉线或者重启，服务器端怎么样才能立刻知道？
TTL是什么？有什么用处，通常那些工具会用到它？ping? traceroute? ifconfig? netstat?
linux的五种IO模式/异步模式.
1）同步阻塞I/O
2）同步非阻塞I/O
3）同步I/O复用模型
4） 同步信号驱动I/O
5） 异步I/O模型
请说出http协议的优缺点.
NAT类型，UDP穿透原理。
大规模连接上来，并发模型怎么设计
五、算法和数据结构
给定一个单向链表（长度未知），请设计一个既节省时间又节省空间的算法来找出该链表中的倒数第m个元素。实现这个算法，并为可能出现的特例情况安排好处理措施。“倒数第m个元素”是这样规定的：当m=0时，链表的最后一个元素将被返回。
解决问题方法思路如下：
方法一、如果我们知道链表的长度n，查找倒数第m个元素，也就是查找正序的第（n - m）个元素（这里的序号只是为了分析，可能跟题目不一定正确的符合）。那么这样来说就简单很多。首先遍历链表得到链表长度，然后重新遍历一次，查找正数第（n-m）个元素。时间复杂度大约是O(2n)。
方法二、我们是不是可以提供一个辅助存储空间，是的我们在遍历到链表结束的时候可以回溯到倒数第m个元素。比如用一个支持随机访问的容器记录链表每一个节点的地址。那么这样的就可以只遍历一次链表就能得到结果。时间复杂度大约是O(n)，但是我们是用空间换取时间的，辅助存储空间的大小由m决定，如果m过大也是不可取的。
方法三、头结点指针为当前指针，尾节点指针为拖后指针。开始的时候当前指针和拖后指针初始化为链表的头结点，首先我们让当前指针遍历到第m个元素，拖后指针不变；然后同步更新当前指针和拖后指针；直到当前指针为链表结尾。这样我们就能保证当前指针和拖尾指针之间的距离是m。
代码如下：
Node* FindMToLastNode(Node* pHead, int m) {
// 查找到第m个元素
Node* pCurrent = pHead;
for (int i = 0; i < m; ++i)
{
if (pCurrent)
{
pCurrent = pCurrent->next;
}
else
{
return NULL;
}
}
Node* pFind = pHead;
while (pCurrent) {
pFind = pFind->next;
pCurrent = pCurrent->next;
}
return pFind;
}
给定一个单向链表（长度未知），请遍历一次就找到中间的指针，假设该链表存储在只读存储器，不能被修改
将一个数组生成二叉排序树
查找数组中第k大的数字？
红黑树的定义和解释？B树的基本性质？
常见的加密算法？
https?
有一个IP库，给你一个IP,如何能够快速的从中查找到对应的IP段？不用数据库如何实现？要求省空间
简述一致性hash算法。
描述一种hash table的实现方法
11、各类树结构的实现和应用
12、hash，任何一个技术面试官必问（例如为什么一般hashtable的桶数会取一个素数？如何有效避免hash结果值的碰撞）
什么是平衡二叉树?
14．数组和链表的优缺点
最小堆插入，删除编程实现
4G的long型整数中找到一个最大的，如何做？
有千万个string在内存怎么高速查找，插入和删除？
100亿个数，求最大的1万个数，并说出算法的时间复杂度
设计一个洗牌的算法，并说出算法的时间复杂度。
20．请分别用递归和非递归方法，先序遍历二叉树
其他各种排序方法
哈希表冲突解决方法？
六、系统架构
设计一个服务，提供递增的SessionID服务，要求保证服务的高可靠性，有哪些方案？集中式/非集中式/分布式
多台服务器要执行计划任务，但只有拿到锁的任务才能执行，有一个中心服务器来负责分配锁，但要保证服务的高可靠性。
如何有效的判断服务器是否存活？服务器是否踢出集群的决策如何产生？
两个服务器如何在同一时刻获取同一数据的时候保证只有一个服务器能访问到数据？
编写高效服务器程序，需要考虑的因素


一.  基础题：
1. linux中内核空间及用户空间的区别？用户空间与内核通信方式有哪些？

linux内核空间和用户空间的是怎样区别的，如何交互，如何从用户空间进入内核空间_bingqingsuimeng的专栏-CSDN博客

2. 字符设备和块设备的区别，请分别列举一些实际的设备说出它们是属于哪一类设备

 字符设备：字符设备是个能够像字节流（类似文件）一样被访问的设备，由字符设备驱动程序来实现这种特性。字符设备驱动程序通常至少实现open,close,read和write系统调用。字符终端、串口、鼠标、键盘、摄像头、声卡和显卡等就是典型的字符设备。

  块设备：和字符设备类似，块设备也是通过/dev目录下的文件系统节点来访问。块设备上能够容纳文件系统，如：u盘，SD卡，磁盘等。

    字符设备和块设备的区别仅仅在于内核内部管理数据的方式，也就是内核及驱动程序之间的软件接口，而这些不同对用户来讲是透明的。在内核中，和字符驱动程序相比，块驱动程序具有完全不同的接口。

3. linux内核的启动过程(源代码级)？

Linux内核启动过程概述 – CrazyCatJack – 博客园

4. linux中系统调用过程？如:应用程序中read()在linux中执行过程即从用户空间到内核空间？

linux设备驱动框架_不忘初心-CSDN博客_linux设备驱动

Linux Read系统调用 – HAOMCU的个人空间 – OSCHINA – 中文开源技术交流社区

5. linux调度原理？

linux内核调度器 调度原理(2.6.24笔记整理)_Janneo.Evans的专栏-CSDN博客

6. 查看驱动模块中打印信息应该使用什么命令？如何查看内核中已有的字符设备的信息？如何查看正在使用的有哪些中断号？

   1) 查看驱动模块中打印信息的命令：dmesg

   2) 查看字符设备信息可以用lsmod 和modprobe，lsmod可以查看模块的依赖关系，modprobe在加载模块时会加载其他依赖的        模块。

   3) 显示当前使用的中断号cat /proc/interrupt

7. copy_to_user()和copy_from_user()主要用于实现什么功能？一般用于file_operations结构的哪些函数里面？

       由于内核空间和用户空间是不能互相访问的，如果需要访问就必须借助内核函数进行数据读写。copy_to_user():完成内核空间到用户空间的复制，copy_from_user()：是完成用户空间到内核空间的复制。一般用于file_operations结构里的read,write,ioctl等内存数据交换作用的函数。当然，如果ioctl没有用到内存数据复制，那么就不会用到这两个函数。

8. 请简述主设备号和次设备号的用途。如果执行mknod chartest c 4 64，创建chartest设备。请分析chartest使用的是那一类设备驱动程序。

1）主设备号：主设备号标识设备对应的驱动程序。虽然现代的linux内核允许多个驱动程序共享主设备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织。

 次设备号：次设备号由内核使用，用于正确确定设备文件所指的设备。依赖于驱动程序的编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数组的索引。

2）chartest 表示设备节点，4表示主设备号，64表示次设备号。（感觉类似于串口终端或者字符设备终端）。

9. 设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义。

    注册一个字符设备驱动有两种方法：

    1） void cdev_init(struct cdev *cdev, struct file_operations *fops)

    该注册函数可以将cdev结构嵌入到自己的设备特定的结构中。cdev是一个指向结构体cdev的指针，而fops是指向一个类似于f       file_operations结构（可以是file_operations结构，但不限于该结构）的指针.

    2） int register_chrdev(unsigned int major, const char *namem , struct file)operations *fopen);

        该注册函数是早期的注册函数，major是设备的主设备号，name是驱动程序的名称，而fops是默认的file_operations结构（这       是只限于file_operations结构）。对于register_chrdev的调用将为给定的主设备号注册0－255作为次设备号，并为每个  设备建     立一个对应的默认cdev结构。

10. linux中RCU原理？

 LINUX中的RCU机制的分析 – eversliver – 博客园

11. linux内存如何划分以及如何使用？虚拟地址及物理地址的概念以及转换，高端内存的概念?

 linux环境内存分配原理–虚拟内存 mallocinfo – dzqdevin – 博客园

 Linux用户空间与内核空间（理解高端内存） – Jessica程序猿 – 博客园

12. 字符型驱动设备怎么创建设备文件?

  手动创建：mknod /dev/led c 250 0    其中dev/led 为设备节点 c 代表字符设备 250代表主设备号 0代表次设备号

     还有UDEV/MDEV自动创建设备文件的方式，UDEV/MDEV是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在用户态意味着系统要运行之后。在  /etc/init.d/rcS 脚本文件中会执行 mdev -s 自动创建设备节点。

13. insmod 一个驱动模块，会执行模块中的哪个函数？rmmod呢？这两个函数在设计上要注意哪些？遇到过卸载驱动出现异常没？是什么问题引起的？

     答： insmod调用init函数，rmmod调用exit函数。这两个函数在设计时要注意什么？卸载模块时曾出现卸载失败的情形，原因是存在进程正在使用模块，检查代码后发现产生了死锁的问题。

 要注意在init函数中申请的资源在exit函数中要释放，包括存储，ioremap，定时器，工作队列等等。也就是一个模块注册进内核，退出内核时要清理所带来的影响，带走一切不留下一点痕迹。

14. 设备驱动模型三个重要成员是？platform总线的匹配规则是？在具体应用上要不要先注册驱动再注册设备？有先后顺序没？

        设备驱动模型三个重要成员是 总线、设备、驱动；

  platfoem总线的匹配规则是：要匹配的设备和驱动都要注册，设备可以在设备树里注册，也可以通过代码注册设备，匹配成功会去调用驱动程序里的probe函数（probe函数在这个platform_driver结构体中注册）。

15. 内核函数mmap的实现原理，机制？

 linux中mmap系统调用原理分析与实现_yinjiabin的博客-CSDN博客_mmap系统调用

 Mmap的实现原理和应用_edwardlulinux的专栏-CSDN博客_mmap原理 

16. 在驱动调试过程中遇到过oops没？你是怎么处理的？

 linux中Oops信息的调试及栈回溯—Linux人都知道，这是好东西！_Android/Linux的专栏-CSDN博客

17. ioctl和unlock_ioctl有什么区别？

 Ioctl使用及与unlocked_ioctl区别_Tim-CSDN博客_unlocked_ioctl的用法

 ioctl与unlocked_ioctl区别_cbl709的专栏-CSDN博客_unlocked_ioctl

18. 驱动中操作物理绝对地址为什么要先ioremap?

   因为内核没有办法直接访问物理内存地址，必须先通过ioremap获得对应的虚拟地址

 Linux 字符设备驱动开发基础（五）—— ioremap() 函数解析_知秋一叶-CSDN博客_ioremap函数

19. 你平常是怎么用C写嵌入式系统的死循环的?

      for(;;){}  

      while(1){}

     一般for(;;)性能更优

     for(;;){}  

     这两个;; 空语句，编译器一般会优掉的，直接进入死循环

    while(1){}  

    每循环一次都要判断常量1是不是等于零，在这里while比for多做了这点事

    不过从汇编的角度来说，都是一样的代码。

20. 列举最少3种你所知道的嵌入式的体系结构，并请说明什么是ARM体系结构。

     arm,mips,x86

 ARM体系结构与编程模型总结_宋铮的博客-CSDN博客_arm体系结构与编程

 ARM体系架构_和蔼的二师兄的专栏-CSDN博客

21. kmalloc和vmalloc的区别

 LINUX内核内存管理kmalloc,vmalloc – 慢伴拍的二叉树 – 博客园

 Kmalloc和Vmalloc的区别 – Jessica程序猿 – 博客园

22. IIC原理，总线框架，设备编写方法，i2c_msg

 i2c总线（基本原理）_不忘初心-CSDN博客_i2c

 简单i2c设备驱动实例_不忘初心-CSDN博客

23.  kernel panic

 Kernel Panic常见原因以及解决方法 – 浩天之家 – 博客园

24.  Linux中的用户模式和内核模式是什么含意？

 linux的用户模式和内核模式_YJF@HZ的博客-CSDN博客

25.  怎样申请大块内核内存？

       vmalloc

26. 用户进程间通信主要哪几种方式？

 https://blog.csdn.net/wh_sjc/article/details/70283843

27.linux编译时用到的参数含义及？

 linux 中常用编译参数解析_yqtao的博客-CSDN博客_linux编译参数

28. 内核配置编译及Makefile?

 Linux内核配置、编译及Makefile简述 – CrazyCatJack – 博客园

29.谈谈对Volatile关键字的理解？

Volatile_不忘初心-CSDN博客

30.  framebuffer机制？

      Linux抽象出FrameBuffer这个设备来供用户态进程实现直接写屏。Framebuffer机制模仿显卡的功能，将显卡硬件结构抽象掉，可以通过Framebuffer的读写直接对显存进行操作。用户可以将Framebuffer看成是显示内存的一个映像，通过mmap将其映射到进程地址空间之后，就可以直接进行读写操作，而写操作可以立即反应在屏幕上。这种操作是抽象的，统一的。用户不必关心物理显存的位置、换页机制等等具体细节，这些都是由Framebuffer设备驱动来完成的。通过mmap调用把显卡的物理内存空间映射到用户空间

二.  同步相关：
1.  spinlock与信号量的区别？

 linux 内核同步机制-自旋锁与信号量及其区别_xiaohuima_dong的专栏-CSDN博客

 蜗窝科技 spin lock (讲的非常不错) – Red_Point – 博客园

2.  linux中的同步机制？

 linux 同步机制 死锁_stevewong的专栏-CSDN博客

 linux同步机制_tong646591的专栏-CSDN博客_linux同步机制

3.  linux系统实现原子操作有哪些方法？

Linux的原子操作与同步机制 – Florian – 博客园

linux内核原子操作的实现_vivi的技术博客-CSDN博客

4.  自旋锁和信号量在互斥使用时需要注意哪些？在中断服务程序里面的互斥是使用自旋锁还是信号量？还是两者都能用？为什么（答案见1分析）？

    答：使用自旋锁的进程不能睡眠,使用执行时间短的任务，使用信号量的进程可以睡眠，适合于执行时间较长的任务。中断服务例程中的互斥使用的是自旋锁，原因是在中断处理例程中，硬中断是关闭的，这样会丢失可能到来的中断。

5. 驱动里面为什么要有并发、互斥的控制？如何实现？讲个例子？

      并发（concurrency）指的是多个执行单元同时、并行被执行，而并发的执行单元对共 享资源（硬件资源和软件上的全局变量、静态变量等）的访问则很容易导致竞态（race conditions）。

       解决竞态问题的途径是保证对共享资源的互斥访问，所谓互斥访问就是指一个执行单元 在访问共享资源的时候，其他的执行单元都被禁止访问。

访问共享资源的代码区域被称为临界区，临界区需要以某种互斥机 制加以保护，中断屏蔽，原子操作，自旋锁，和信号量都是linux设备驱动中可采用的互斥途径。

三.  中断相关：
可以先看一下五篇系列文章：https://blog.csdn.net/droidphone/article/category/1118447

      这篇我收藏的文档详细的叙述了中断上半部及下半部的原理及注意点，如果对其不理解可以下载下来看看，由于CSDN最低没有0积分，那就最低的一个积分吧。下载地址：linux设备驱动中断之上半部和下半部_中断上半部和下半部,linux中断上半部与下半部-Android文档类资源-CSDN下载

1.  linux中软中断的实现原理？

 Linux中断（interrupt）子系统之五：软件中断（softIRQ）_DroidPhone的专栏-CSDN博客 

 硬中断与软中断的区别_Linux编程_Linux公社-Linux系统门户网站

2. linux中断响应的执行流程

 linux中断流程详解_yimu13的专栏-CSDN博客_linux中断处理流程

3. linux中断实现机制、tasklet和workqueue的区别和底层实现的区别，为什么要区分中断上半部和中断下半部。

  （中断上半部及下半部详细文档：linux设备驱动中断之上半部和下半部_中断上半部和下半部,linux中断上半部与下半部-Android文档类资源-CSDN下载）

tasklet和workqueue区别？ 
 tasklet运行于中断上下文，不允许阻塞 、休眠，而workqueue运行与进程上下文，可以休眠和阻塞。 
为什么要区分上半部和下半部？ 
 中断服务程序异步执行，可能会中断其他的重要代码，包括其他中断服务程序。因此，为了避免被中断的代码延迟太长的时间，中断服务程序需要尽快运行，而且执行的时间越短越好，所以中断程序只作必须的工作，其他工作推迟到以后处理。所以Linux把中断处理切为两个部分：上半部和下半部。上半部就是中断处理程序，它需要完成的工作越少越好，执行得越快越好，一旦接收到一个中断，它就立即开始执行。像对时间敏感、与硬件相关、要求保证不被其他中断打断的任务往往放在中断处理程序中执行；而剩下的与中断有相关性但是可以延后的任务，如对数据的操作处理，则推迟一点由下半部完成。下半部分延后执行且执行期间可以相应所有中断，这样可使系统处于中断屏蔽状态的时间尽可能的短，提高了系统的响应能力。实现了程序运行快同时完成的工作量多的目标。

4. 中断的申请及何时执行(何时执行中断处理函数)？

    中断的响应流程：cpu接受中断->保存中断上下文跳转到中断处理历程->执行中断上半部->执行中断下半部->恢复中断上下文。 
 中断的申请request_irq的正确位置：应该是在第一次打开 、硬件被告知终端之前。

5. 中断注册函数和中断注销函数

 6.分析request_irq和free_irq函数如何注册注销中断(详解) – 诺谦 – 博客园

6. 中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？

    中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求。凡事都是两面性，所以，看效率不能简单的说那个效率高。如果是请求设备是一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。如果是一般设备，并且该设备请求cpu的频率比较底，则用中断效率要高一些。主要是看请求频率。

7. 写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？

    第一： 中断处理例程应该尽量短，把能放在后半段(tasklet，等待队列等)的任务尽量放在后半段。

     写一个中断服务程序要注意快进快出，在中断服务程序里面尽量快速采集信息，包括硬件信息，然后退出中断，要做其它事情可以使用工作队列或者tasklet方式。也就是中断上半部和下半部。

    第二：中断服务程序中不能有阻塞操作。应为中断期间是完全占用CPU的（即不存在内核调度），中断被阻塞住，其他进程将无法操作；

    第三：中断服务程序注意返回值，要用操作系统定义的宏做为返回值，而不是自己定义的OK，FAIL之类的。

8. 驱动中操作物理绝对地址为什么要先ioremap?

    因为内核没有办法直接访问物理内存地址，必须先通过ioremap获得对应的虚拟地址。

9.  IRQ和FIQ有什么区别，在CPU里面是是怎么做的？

 FIQ和IRQ的区别及CPU实现_逐波与逆流-CSDN博客_fiq和irq的区别

10. Linux软中断和工作队列的作用是什么？

 Linux内核中的软中断、tasklet和工作队列详解_godleading的专栏-CSDN博客_tasklet

 参考文章：linux驱动工程面试必问知识点

 linux驱动工程面试必问知识点_OpenWrt/WLAN/驱动/嵌入式开发总结-CSDN博客

 Linux 驱动面试题总结_知秋一叶-CSDN博客_linux驱动开发面试题

 https://blog.csdn.net/lhhero701/article/details/51171948
